# 我对C/C++的理解
> 我已建立数据类型的概念，包括基础数据类型、复合数据类型（指针）
> 也知道函数定义和函数调用的概念，编译器在编译源码时，会自动加上startup
> 代码，由启动代码调用main函数，每次函数调用都会建立**栈帧**，在栈帧上
> 保存了必要的局部变量。有些局部变量会被优化到寄存器中，以加速程序
> 执行，但如果要通过&取地址符号取址某变量，那么编译器必须在当前栈帧中分配
> 相应的空间，并把该地址赋给指向它的指针。

## 指针
> 指针是变量，也占有空间，它的大小是由系统决定的，一般因32位/64位机器
> 而分得4字节/8字节空间。同时，指针是复合数据类型，指向整型和指向浮点型的
> 指针不是同一个类型，因为在译码过程中读取的位数是不同的，对它们的解释也不同。

## 内存模型
> 通过编译得到的可执行文件是一种镜像，它描述了执行代码和操作数据如何
> 映射到内存中，操作系统执行某个程序，首先利用加载器去读取该文件，然后按照
> 编译器和操作系统之间的约定，将不同部分的数据分配到内存的不同位置上，
> 这就是**加载**过程。

> 内存主要分为如下几个区域：静态数据区、只读数据区、栈段、堆段，还有一部分
> 是内核映射区，那部分是所有进程共享的。它是操作系统代码常驻的区域。上面提
> 到的每次函数调用都会分配一个栈帧就是分配在栈段中，通过bp和sp寄存器指定。
> 该区域负责函数调用过程中实参传递和返回值传递，调用函数（caller function）
> 和被调函数（callee function)的寄存器保存（叫**压栈**），以及保存函数返回
> 后下一个要继续执行的代码的地址(叫**保护现场**)。

> 可以认为局部变量就保存在栈区，通过malloc或new分配的空间在堆段，全局变量保
> 存在静态数据区，代码保存在只读数据区域。这不难理解，全局变量的作用域不属于
> 任何函数，在main函数开始执行前，全局变量的空间就已经存在了。所以在程序进入
> main函数前其实就以及做了很多准备工作了。

> 从程序执行的角度看，就这些东西。但是现代编程语言是相当复杂的工程，从源程序到
> 可执行程序，再经过程序加载过程，形成**进程**，要经历很多阶段。面对越来越复杂的现实
> 问题，程序也变得越发庞大，编程语言也加入了更多特性，让程序员更轻松的驾驭编程
> 过程。总结起来就是**编程思想**或者**编程范式**，从早期的**结构化编程**到**面向
> 对象编程**，再到**泛型编程**，目的都是为了让程序员更好的写出可靠性高、易维护
> 和可重用的代码。

## 万变不离其宗
> 面对这样复杂如摩天大楼似的软件工程，一定要有这样的信念。找到合适的路径，付出足够的
> 努力和耐心，一定可以“登顶”

## 去掉那些不重要的细枝末节

> 程序涵盖了成千上万的概念和知识点，但它们并不是都那么重要，有些概念和知识点值得
> 你反复琢磨，而有些重要了解就够了，或者说是用到时查看一下就行了。而且，概念之间也
> 是分层次的，就像是摩天大楼，一层一层盖上去，从地基到框架，从硬装到软装，建造起来
> 是按步骤进行的。要抓住那些核心的支柱概念，才能最终成功“登顶”。

### 下面是我认为不重要的

1. 输入输出格式不重要，对用户体验来说比较重要，但是在后期专门花点时间修饰它就好，
初学者不需要花太多时间在这上面。
2. 操作符的优先级不重要，因为它们不是编程必须要了解的知识。如果可能多加括号，或者总
是另起一行就行了。
3. 二进制表示，它是比较复杂的，有反码、补码，浮点数表示、ASCII、Unicode编码等，在
某个时候看一下大概的原理，抓住核心就OK。

### 下面是我认为的非常非常核心的概念
> 掌握它们就能读、能写高质量的程序，切换到其他任何一门编程语言都轻而易举。也能够
> 在面对现实中千变万化、纷繁复杂的建模领域时得心应手。

函数  
- 定义
- 调用
- 返回值
- 作用域  
- 算法

对象  
- 数据对象
- 操作对象
- OOP对象
- 模板对象（泛型） 
- 作用域
- 对象与类型的关系

类型  
- 类型分类与表示
- 类型系统
- 类型推导
- 类型转换
- 类型与语义的关系
- 抽象数据类型（ADT）

访问权限
- 对象的作用域
- 数据和操作相互指向
- 类型空间  

内存模型
- 对象生命周期
- 存储位置
- 占用空间

